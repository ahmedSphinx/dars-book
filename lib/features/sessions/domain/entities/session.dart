import 'package:equatable/equatable.dart';

class Session extends Equatable {
  final String id;
  final DateTime dateTime;
  final bool hasBooklet;
  final String? note;
  final List<Attendance> attendances;

  const Session({
    required this.id,
    required this.dateTime,
    required this.hasBooklet,
    this.note,
    this.attendances = const [],
  });

  /// Factory constructor with validation
  factory Session.create({
    required String id,
    required DateTime dateTime,
    required bool hasBooklet,
    String? note,
    List<Attendance> attendances = const [],
  }) {
    // Allow empty ID for new sessions (will be generated by repository)
    if (dateTime.isAfter(DateTime.now().add(const Duration(days: 365)))) {
      throw ArgumentError('Session date cannot be more than 1 year in the future');
    }
    if (dateTime.isBefore(DateTime.now().subtract(const Duration(days: 365)))) {
      throw ArgumentError('Session date cannot be more than 1 year in the past');
    }
    
    return Session(
      id: id,
      dateTime: dateTime,
      hasBooklet: hasBooklet,
      note: note,
      attendances: attendances,
    );
  }

  /// Factory constructor for creating new sessions (without ID)
  factory Session.createNew({
    required DateTime dateTime,
    required bool hasBooklet,
    String? note,
    List<Attendance> attendances = const [],
  }) {
    if (dateTime.isAfter(DateTime.now().add(const Duration(days: 365)))) {
      throw ArgumentError('Session date cannot be more than 1 year in the future');
    }
    if (dateTime.isBefore(DateTime.now().subtract(const Duration(days: 365)))) {
      throw ArgumentError('Session date cannot be more than 1 year in the past');
    }
    
    return Session(
      id: '', // Empty ID for new sessions
      dateTime: dateTime,
      hasBooklet: hasBooklet,
      note: note,
      attendances: attendances,
    );
  }

  Session copyWith({
    String? id,
    DateTime? dateTime,
    bool? hasBooklet,
    String? note,
    List<Attendance>? attendances,
  }) {
    return Session(
      id: id ?? this.id,
      dateTime: dateTime ?? this.dateTime,
      hasBooklet: hasBooklet ?? this.hasBooklet,
      note: note ?? this.note,
      attendances: attendances ?? this.attendances,
    );
  }

  @override
  List<Object?> get props => [id, dateTime, hasBooklet, note, attendances];

  /// Get total revenue from all attendances
  double get totalRevenue => attendances
      .where((attendance) => attendance.present)
      .fold(0.0, (sum, attendance) => sum + attendance.totalCharge);

  /// Get number of present students
  int get presentCount => attendances.where((attendance) => attendance.present).length;

  /// Get number of absent students
  int get absentCount => attendances.where((attendance) => !attendance.present).length;

  /// Get total number of students
  int get totalStudents => attendances.length;

  /// Check if session is in the past
  bool get isPast => dateTime.isBefore(DateTime.now());

  /// Check if session is today
  bool get isToday {
    final now = DateTime.now();
    return dateTime.year == now.year &&
           dateTime.month == now.month &&
           dateTime.day == now.day;
  }

  /// Check if session is in the future
  bool get isFuture => dateTime.isAfter(DateTime.now());

  /// Get formatted date string
  String get formattedDate {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final sessionDate = DateTime(dateTime.year, dateTime.month, dateTime.day);
    
    if (sessionDate == today) {
      return 'اليوم';
    } else if (sessionDate == today.add(const Duration(days: 1))) {
      return 'غداً';
    } else if (sessionDate == today.subtract(const Duration(days: 1))) {
      return 'أمس';
    } else {
      return '${dateTime.day}/${dateTime.month}/${dateTime.year}';
    }
  }

  /// Get formatted time string
  String get formattedTime {
    final hour = dateTime.hour.toString().padLeft(2, '0');
    final minute = dateTime.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }

  /// Check if session has any attendance
  bool get hasAttendance => attendances.isNotEmpty;

  /// Get attendance rate (percentage of present students)
  double get attendanceRate {
    if (attendances.isEmpty) return 0.0;
    return (presentCount / totalStudents) * 100;
  }
}

class Attendance extends Equatable {
  final String studentId;
  final String studentName;
  final bool present;
  final double lessonPriceSnap;
  final double bookletPriceSnap;
  final double sessionCharge;
  final double bookletCharge;

  const Attendance({
    required this.studentId,
    required this.studentName,
    required this.present,
    required this.lessonPriceSnap,
    required this.bookletPriceSnap,
    required this.sessionCharge,
    required this.bookletCharge,
  });

  /// Factory constructor with validation
  factory Attendance.create({
    required String studentId,
    required String studentName,
    required bool present,
    required double lessonPriceSnap,
    required double bookletPriceSnap,
    required double sessionCharge,
    required double bookletCharge,
  }) {
    if (studentId.isEmpty) {
      throw ArgumentError('Student ID cannot be empty');
    }
    if (studentName.isEmpty) {
      throw ArgumentError('Student name cannot be empty');
    }
    if (lessonPriceSnap < 0) {
      throw ArgumentError('Lesson price cannot be negative');
    }
    if (bookletPriceSnap < 0) {
      throw ArgumentError('Booklet price cannot be negative');
    }
    if (sessionCharge < 0) {
      throw ArgumentError('Session charge cannot be negative');
    }
    if (bookletCharge < 0) {
      throw ArgumentError('Booklet charge cannot be negative');
    }
    
    return Attendance(
      studentId: studentId,
      studentName: studentName,
      present: present,
      lessonPriceSnap: lessonPriceSnap,
      bookletPriceSnap: bookletPriceSnap,
      sessionCharge: sessionCharge,
      bookletCharge: bookletCharge,
    );
  }

  double get totalCharge => sessionCharge + bookletCharge;

  Attendance copyWith({
    String? studentId,
    String? studentName,
    bool? present,
    double? lessonPriceSnap,
    double? bookletPriceSnap,
    double? sessionCharge,
    double? bookletCharge,
  }) {
    return Attendance(
      studentId: studentId ?? this.studentId,
      studentName: studentName ?? this.studentName,
      present: present ?? this.present,
      lessonPriceSnap: lessonPriceSnap ?? this.lessonPriceSnap,
      bookletPriceSnap: bookletPriceSnap ?? this.bookletPriceSnap,
      sessionCharge: sessionCharge ?? this.sessionCharge,
      bookletCharge: bookletCharge ?? this.bookletCharge,
    );
  }

  @override
  List<Object?> get props => [
        studentId,
        studentName,
        present,
        lessonPriceSnap,
        bookletPriceSnap,
        sessionCharge,
        bookletCharge,
      ];
}

